---
title: "A quick introduction to 'spatialwarnings'"
author: "Alexandre GÃ©nin"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spatialwarnings}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  cache = TRUE, 
  out.width = "700px"
)
```

```{r spw_setup}
library(spatialwarnings)
# Setup parallel computing 
options(mc.cores = 4)

# Install some packages which are needed by this vignette
if ( ! require(tiff) ) { 
  install.packages('tiff') 
} 
if ( ! require(png) ) { 
  install.packages('png') 
} 
if ( ! require(gridExtra) ) { 
  install.packages('gridExtra') 
} 
# EBImage can be installed from Bioconductor repositories: 
# https://www.bioconductor.org/packages/release/bioc/html/EBImage.html
if ( ! require(EBImage) ) { 
  source("https://bioconductor.org/biocLite.R")
  biocLite("EBImage", suppressUpdates = TRUE)
}

```



# Identifying periodicity in data 

EWS available in \texttt{spatialwarnings} assume that stress does not affect the 
periodicity of the spatial structure, as changes in periodicity may mask mask of 
alter trends in indicator values. Before computing the EWS, it is therefore 
needed to check for any possible periodicity in the input data. In this 
appendix, we contrast two images to show how the r-spectrum can be used to 
highlight periodicity (or its absence), and we show the R code used to run these 
analyses. 

```{r computation}

# Load packages
library(png)     # image-reading package
library(ggplot2) # plotting 
library(spatialwarnings)

# Read images
image_periodic <- readPNG('./patterned_bush_niger.png')
image_nonper   <- readPNG('./non_patterned_spain.png')

# The images have three bands (R/G/B). We transform them into a black 
# and white image using principal component analysis (PCA)
summarise_pca <- function(arr) { 
  values <- matrix(as.vector(arr), ncol = 3)
  pca <- prcomp(values)
  values <- pca[["x"]][ ,1]
  matrix(values, ncol = ncol(arr), nrow = nrow(arr)) 
}

# Transform into one-band (black and white image) and compute r-spectrum. 
image_periodic_pca <- summarise_pca(image_periodic)
rspec_periodic <- rspectrum(image_periodic_pca)

image_nonper_pca <- - summarise_pca(image_nonper)
rspec_nonper <- rspectrum(image_nonper_pca)

```

```{r plot_functions, echo = FALSE, print = FALSE}
# Transform a matrix into ggplot-compatible data.frame
mat2longdf <- function(mat) { 
  data.frame(expand.grid(y = seq.int(ncol(mat)), 
                         x = seq.int(nrow(mat))), 
             value = as.vector(mat))
}

# Counter to add letters to figures 
counter <- 0 
lettercount <- function() letters[counter <<- counter + 1]

# Make series of breaks/labels for log scale
brks <- as.vector(outer(seq.int(9), 10^seq(-10, 10)))
brks.major <- brks[grepl("^1",  brks, perl = TRUE)]
brks.minor <- brks[!grepl("^1", brks, perl = TRUE)]
lbls <- ifelse(grepl('^(1|2|5)', brks.major, perl = TRUE), brks.major, "")
scale_x <- scale_x_continuous(trans = "log10", 
                              breaks = brks.major[brks.major>0], 
                              minor_breaks = brks.minor[brks.minor>0], 
                              labels = lbls[brks.major>0])
scale_y <- scale_y_continuous(trans = "log10", 
                              breaks = brks.major, 
                              minor_breaks = brks.minor, 
                              labels = lbls)
```

The periodic image below (tiger bush in Niger [^1]) displays a typical banded 
regular pattern (a). Its scale (in number of pixels) is reflected by a hump in 
the r-spectrum around a size of ~ 15px (b). This corresponds to the width of one 
vegetation band in the image (~30m in reality).  

[^1]: https://www.google.com/maps/place/12%C2%B030'47.3%22N+3%C2%B000'49.9%22E/@12.5131562,3.0116833,905m/data=!3m2!1e3!4b1!4m5!3m4!1s0x0:0x0!8m2!3d12.513151!4d3.013872?hl=en]

```{r display_periodic, fig.width = 12, fig.height = 6, echo = FALSE} 

img <- ggplot(mat2longdf(image_periodic_pca)) + 
        geom_raster(aes(x = x, y = y, fill = value)) + 
        scale_fill_gradient(low = "black", high = "white") + 
        scale_y_reverse() + 
        theme_minimal() + 
        theme(legend.position = "none") + 
        labs(x = "Pixel coordinate", 
            y = "Pixel coordinate", 
            title = paste0(lettercount(), ") Image of periodic vegetation"))

rsp <- ggplot(rspec_periodic) + 
         geom_point(aes(x = dist, y = rspec), pch = 20) + 
         scale_x + scale_y + 
         theme_minimal() + 
         labs(x = "Distance (number of pixels)", 
             y = "r-spectrum value (power)", 
             title = paste0(lettercount(), ") r-spectrum of periodic image"))

gridExtra::grid.arrange(img, rsp, ncol = 2)

```

This image displays strong periodicity and the indicators in 
\texttt{spatialwarnings} should be used with care to draw conclusions from it. 

In contrast, an aperiodic image displays no such hump in its r-spectrum. The 
image below (c, arid grassland in Spain) is aperiodic, as shown by the 
decreasing r-spectrum (d). Indicators available in 
\texttt{spatialwarnings} may (in principle) be used on this image. 

```{r display_nonperiodic, fig.width = 12, fig.height = 6, echo = FALSE}

img <- ggplot(mat2longdf(image_nonper_pca)) + 
        geom_raster(aes(x = x, y = y, fill = value)) + 
        scale_fill_gradient(low = "black", high = "white") + 
        scale_y_reverse() + 
        theme_minimal() + 
        theme(legend.position = "none") + 
        labs(x = "Pixel coordinate", 
            y = "Pixel coordinate", 
            title = paste0(lettercount(), ") Image of non-periodic vegetation"))

rsp <- ggplot(rspec_nonper) + 
         geom_point(aes(x = dist, y = rspec), pch = 20) + 
         scale_x + scale_y + 
         theme_minimal() + 
         labs(x = "Distance (number of pixels)", 
             y = "r-spectrum value (power)", 
             title = paste0(lettercount(), ") r-spectrum of non-periodic image"))

gridExtra::grid.arrange(img, rsp, ncol = 2)

```



# Classifying/summarizing multi-band images for use in spatialwarnings

Raster images from remote sensing often come with multiple bands, because 
of the way images are stored digitally (e.g. red/blue/green bands), but also 
because multiple sensors can be used to capture a single image (e.g. a 
combination of visible/near-infrared sensors). These images are often represented
as arrays in R (matrices that are extended with a third dimension, "depth"). 

As `spatialwarnings` computes indicators on `matrix` objects, these arrays need 
to be first transformed into matrices (effectively arrays with no depth). This 
entails summarizing the multi-dimensional data of each pixel to a single value. 
In addition, some indicators (e.g. patch-based indicators) rely on classified, 
`TRUE/FALSE` data that defines which pixels belong to a patch and which do not. 
Again, the classification algorithm employed is likely to be very 
system-dependent, but we provide a possible example below. 

In what follows, we use a case-study to show how to carry these two processes 
and apply the `spatialwarnings` package on images. Using an aerial image 
stored as an R/G/B PNG image, we classify each pixel as vegetated/non-vegetated
or summarize the multi-channel pixel values to a single value. We then apply the
indicators on the resulting transformed matrix. 

Note that in many cases, other methods can be used to derive univariate indices 
from remote sensing data that may be more appropriate to describe the focal 
system. For example, a typical one-dimensional index for vegetation data is NDVI 
(Normalized Difference Vegetation Index), which measures the extent of green 
vegetation in a given pixel and is obtained as the normalized difference between 
the red a near-infrared bands of a multi-band image. 


## Classifying an RGB image to compute patch-based indicators 

We first load the required packages and read the image in R. 

```{r pkgs}
library(png) # Read PNG images as arrays
library(plyr) # Manipulate data.frames
library(tidyr) # Manipulate data.frames
library(ggplot2) # Make plots
library(spatialwarnings) 

# Read image
datadir <- "../figs/images/"
img1 <- readPNG('./crau_quercus_encroachment.png')

# Display image 
grid::grid.raster(img1)

```

The vegetation in this image displays some patchiness, that can be characterized by `spatialwarnings`. `img1` is a raster image 
with three (red/blue/green) channels that need to be be classified into `TRUE` 
(pixel is in a vegetation patch) or `FALSE` values in order to compute patch-based 
compute indicators. 

```{r densities, fig.width = 16, fig.height = 6} 
# Convert the image to a data.frame 
img1_tab <- data.frame(expand.grid(x = seq.int(nrow(img1)), 
                                   y = seq.int(ncol(img1))), 
           as.data.frame(matrix(img1, ncol = 3)))
names(img1_tab) <- c('x', 'y', 'red', 'green', 'blue')

# A very bright object is present in the image, that distorts the results 
# further down and needs to be removed. We set its pixel values to NAs. 
luminance <- with(img1_tab, sqrt( 0.299*red^2 + 0.587*green^2 + 0.114*blue^2 ))
img1_tab[ ,c('red', 'green', 'blue')] <- 
  img1_tab[ ,c('red', 'green', 'blue')] * ifelse(luminance > .5, NA, 1)

```

We can display the distribution of each channel values: 

```{r channel_values_distribution}
# fix level order so colors match in graph
df <- gather(img1_tab, channel, value, red, green, blue)
df[ ,'channel'] <- factor(df[ ,'channel'], levels = c("red", "green", "blue"), 
                          ordered = TRUE) 
ggplot( df ) + 
  geom_density(aes(x = value, color = channel)) +
  theme_minimal() +
  labs(caption = "Distribution of channel values") + 
  scale_color_manual(values = c('red', 'green', 'blue', 'black')) 
```

Each individual channel can be also represented as a monochrome image: 

```{r each_channel_independently}
ggplot(gather(img1_tab, channel, value, red, green, blue)) + 
  geom_raster(aes(x = x, y = y, fill = value)) + 
  facet_grid( ~ channel, labeller = label_both) + 
  coord_fixed() + 
  theme_minimal() + 
  scale_fill_gradient(low = "#000000", high = "#FFFFFF") + 
  labs(caption = "Monochrome representation of the three channels of the RGB image")
```

We can classify this image using an unsupervised k-means classification 
algorithm on the pixel data. Many other classification algorithms exist and may 
show better accuracy, but k-means is simple, generic and fast. 

```{r kmeans}

km <- kmeans(na.omit(img1_tab[ ,c('red', 'green', 'blue')]), 
             centers = 2)
img1_tab[ ,'clust'] <- NA
img1_tab[!is.na(img1_tab[ ,'red']), 'clust'] <- km[['cluster']]

# The number identifying each cluster is random in k-means: we make sure that 
# cluster 2 always has greener values, and thus always corresponds to potential 
# vegetation patches. 
img1_tab[ ,'clust'] <- with(img1_tab, as.integer(reorder(as.factor(clust), -green)))

ggplot(img1_tab) + 
  geom_raster(aes(x = x, y = y, 
                  fill = as.factor(clust))) + 
  coord_fixed() + 
  theme_minimal() + 
  scale_fill_manual(values = c('#F4EAA4', '#0A8E0B'))

```

Cluster 2 roughly identifies vegetation patches, but many single-pixel values 
are misclassified by the k-means algorithm. However, they most likely pertain to 
the nearest patch: we apply a smoothing filter to get rid of them. 

```{r filter}

clust_filt <- with(img1_tab, 
                   gblur(matrix(!is.na(clust) & clust == 2, 
                                nrow = max(x), ncol = max(y)), 
                                sigma = 1.5)) > .2

img1_tab[ ,'clust_filt'] <- as.vector(clust_filt)

ggplot(img1_tab) + 
  geom_raster(aes(x = x, y = y, 
                  fill = as.factor(clust_filt))) + 
  coord_fixed() + 
  theme_minimal() + 
  scale_fill_manual(name = "Vegetation", 
                    values = c('#F4EAA4', '#0A8E0B'))

```

We can then apply the patch-based indicators on the resulting classified 
matrix. 

```{r psd_indics}

psd_indic <- patchdistr_sews(clust_filt, fit_lnorm = TRUE)

summary(psd_indic)

plot_distr(psd_indic, best_only = FALSE) + 
  labs(title = "Results of patch-size distribution fitting")

```

Note that this brief demonstration uses k-means, but many classification methods 
exist, either supervised or unsupervised (Liu and Mason, 2016) and may show 
better results depending on the focal system. 





## Reducing the dimensionality of pixel data

Indicators require each pixel to have a single, uni-dimensional value. One 
option is to use the values of each channel independently (e.g. using red values 
only), but these may not represent the state of the system most accurately. 
Ideally, each pixel should carry a value that defines as accurately the state of 
the system. 

Similar to classifications, supervised and unsupervised methods exist to 
summarize three-dimensional information to a single value. A simple generic 
unsupervised method is Principal Component Analysis (see e.g. Liu and Mason, 
2016 for more details about its application on raster images), which we 
use here as example. 

We carry out a PCA on the pixel data: 

```{r pca}

# We use the red/green/blue information and combine them using PCA
NApixel <- is.na(img1_tab[ ,'red'])
pca <- prcomp(img1_tab[!NApixel, c('red', 'green', 'blue')])

summary(pca)

# Import data back into data.frame
img1_tab[ ,'pca1'] <- NA
img1_tab[!NApixel,'pca1'] <- predict(pca)[ ,1]

ggplot(img1_tab) + 
  geom_raster(aes(x = x, y = y, fill = pca1)) + 
  coord_fixed() + 
  theme_minimal()

```

Results from PCA show that the first axis explains 98% of the variance in RGB 
value, so it summarizes very well the variations in pixel values. We can then 
apply indicators on these univariate values (we use here the example of spectral 
indicators). 

Note that because there are some `NA` values (`r sprintf("%1.2f%%", 
round(mean(is.na(img1_tab$pca)), 4)* 100)` of all pixels) in the input image 
(the pixels where a very bright object is present), we need to interpolate them 
before computing the indicators. Note that interpolation increases the 
autocorrelation in a given matrix and indicators should be interpreted with 
caution on matrices where a large amount of pixels have been interpolated. 

```{r indic}

# Convert to matrix format then compute indicators. Because there are NA 
# values in the input image, we need to interpolate these values. We fill the 
# pixels with NAs with the mean value of their direct neighbors. 
pca_mat <- with(img1_tab, matrix(pca1, ncol = max(y), nrow = max(x)))
while ( any( is.na(pca_mat) ) ) { 
  for (i in seq.int(nrow(pca_mat))) { 
    if ( any(is.na(pca_mat[i, ])) ) { 
      for (j in seq.int(ncol(pca_mat))) { 
        
        # Bound check on the matrix
        i2 <- min(i, 1, nrow(pca_mat))
        j2 <- min(j, 1, ncol(pca_mat))
        if ( is.na(pca_mat[i, j]) ) { 
          pca_mat[i, j] <- mean(pca_mat[(i2-1):(i2+1), 
                                        (j2-1):(j2+1)])
        }
      }
    }
  }
} 
```

We can then compute the indicators on the resulting matrix: 

```{r indicator_compute}

# Compute spectral indicators 
ic <- spectral_sews(pca_mat, 
                    sdr_low_range = c(0, .2), 
                    sdr_high_range = c(.8, 1))
ic <- indictest(ic, nperm = 499)

# Display textual summary 
summary(ic)

```

Note that while PCA may summarize well arbitrary variations in R/G/B pixel 
values, this does not mean that the resulting pixel values always capture well 
the variations in the system state. Before interpreting indicators, it is 
necessary to understand well how the numerical values in the image reflect the 
state of the ecological system. The use of indices known to reflect a specific 
aspect of the system (e.g. NDVI reflecting the amount of green vegetation cover) 
may be often more informative than using a generic algorithm to collapse 
multiple channels into one. 

# References

Liu and Mason, 2016. Image Processing and GIS for Remote Sensing: Techniques and 
Applications. John Wiley \& Sons, Ltd. 


